// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Plan {
  BASIC
  STANDARD
  PREMIUM
}

enum SessionStatus {
  STARTED
  AWAITING_PAYMENT
  PAID
  PAID_PENDING_EMAIL
  COMPLETED
  REFUNDED
  FAILED
}

enum ActionType {
  SESSION_CREATED
  EMAIL_COLLECTED
  PAYMENT_RECEIVED
  PAYMENT_VERIFIED
  ACCESS_GRANTED
  EMAIL_RESENT
  EMAIL_UPDATED
  ACCESS_MANUALLY_GRANTED
  EMAIL_SENT_ADMIN
  WEBHOOK_SENT
  WEBHOOK_FAILED
}

enum Role {
  ADMIN
  MANAGER
}

enum PublicationStatus {
  PENDING      // Создано, ждет отправки
  PROCESSING   // Отправлено в Make
  PUBLISHED    // Успешно опубликовано
  PARTIAL      // Опубликовано частично
  FAILED       // Ошибка
  CANCELLED    // Отменено
}

model User {
  id          String   @id @default(uuid())
  email       String?  @unique
  firstName   String?  @map("first_name")
  lastName    String?  @map("last_name")
  phoneNumber String?  @map("phone_number")
  tgUserId    String?  @unique @map("tg_user_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  sessions Session[]

  @@map("users")
}

model Session {
  id            String        @id @default(uuid())
  sessionId     String        @unique @map("session_id")
  txnId         String?       @unique @map("txn_id")
  plan          Plan
  emailUser     String?       @map("email_user")
  emailPaypal   String?       @map("email_paypal")
  amount        Decimal       @db.Decimal(10, 2)
  currency      String        @default("USD")
  status        SessionStatus @default(STARTED)
  paymentDate   DateTime?     @map("payment_date")
  endDate       DateTime?     @map("end_date")
  meta          Json?         @default("{}")
  userId        String?       @map("user_id")
  createdAt     DateTime      @default(now()) @map("created_at")
  updatedAt     DateTime      @updatedAt @map("updated_at")

  user     User?      @relation(fields: [userId], references: [id])
  actions  Action[]

  @@index([sessionId])
  @@index([txnId])
  @@index([status])
  @@index([plan])
  @@index([createdAt])
  @@map("sessions")
}

model Action {
  id        String     @id @default(uuid())
  type      ActionType
  ref       String?    // session_id, txn_id, or user_id
  payload   Json?      @default("{}")
  sessionId String?    @map("session_id")
  createdAt DateTime   @default(now()) @map("created_at")

  session Session? @relation(fields: [sessionId], references: [id])

  @@index([type])
  @@index([ref])
  @@index([sessionId])
  @@index([createdAt])
  @@map("actions")
}

model WebUser {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String   @map("password_hash")
  role         Role     @default(MANAGER)
  firstName    String?  @map("first_name")
  lastName     String?  @map("last_name")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  passwordResetCodes PasswordResetCode[]
  chatSessions       ChatSession[]
  publications       Publication[]

  @@map("web_users")
}

model PasswordResetCode {
  id        String   @id @default(uuid())
  code      String   @unique
  userId    String   @map("user_id")
  email     String
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  user WebUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@map("password_reset_codes")
}

model ChatSession {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  fileName      String   @map("file_name")
  fileType      String   @map("file_type")
  fileSize      Int      @map("file_size")
  filePath      String?  @map("file_path")
  extractedData Json     @map("extracted_data") @db.JsonB
  metadata      Json?    @default("{}") @db.JsonB
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user     WebUser       @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@index([userId])
  @@index([createdAt])
  @@map("chat_sessions")
}

model ChatMessage {
  id        String      @id @default(uuid())
  sessionId String      @map("session_id")
  role      String      // 'user' or 'assistant'
  content   String      @db.Text
  createdAt DateTime    @default(now()) @map("created_at")

  session ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
  @@map("chat_messages")
}

model Publication {
  id          String            @id @default(uuid())
  userId      String            @map("user_id")

  // Content
  title       String
  description String            @db.Text
  videoPath   String            @map("video_path")
  videoUrl    String?           @map("video_url")
  thumbnailPath String?         @map("thumbnail_path")
  thumbnailUrl String?          @map("thumbnail_url")

  // Target platforms (stored as JSON array: ["instagram", "tiktok"])
  platforms   Json

  // Status tracking
  status      PublicationStatus @default(PENDING)
  makeWebhookSent Boolean       @default(false) @map("make_webhook_sent")
  makeResponse Json?            @map("make_response")

  // Platform-specific results (JSON: { "instagram": { "success": true, "postId": "..." }, ... })
  publishResults Json?          @map("publish_results")

  // Video metadata
  fileSize    Int?              @map("file_size")
  duration    Int?              // seconds
  format      String?
  resolution  String?

  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt @map("updated_at")
  publishedAt DateTime?         @map("published_at")

  user        WebUser           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("publications")
}

